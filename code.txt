--- CMakeLists.txt ---
cmake_minimum_required(VERSION 3.16.0)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)

project(idrive)

--- idf_component.yml ---
dependencies:
  espressif/esp_tinyusb: "^1.1"

--- platformio.ini ---
; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:esp32-s3-devkitc-1]
platform = espressif32
board = esp32-s3-devkitc-1
framework = espidf


--- include\idrive.h ---
#ifndef IDRIVE_H
#define IDRIVE_H

#include <stdint.h>

// Incoming
#define MSG_IN_INPUT 0x267
#define MSG_INPUT_BUTTON 0xC0
#define MSG_INPUT_BUTTON_MENU 0x01
#define MSG_INPUT_BUTTON_BACK 0x02
#define MSG_INPUT_BUTTON_OPTION 0x04
#define MSG_INPUT_BUTTON_RADIO 0x08
#define MSG_INPUT_BUTTON_CD 0x10
#define MSG_INPUT_BUTTON_NAV 0x20
#define MSG_INPUT_BUTTON_TEL 0x40

#define MSG_INPUT_CENTER 0xDE
#define MSG_INPUT_STICK 0xDD
#define MSG_INPUT_STICK_UP 0x01
#define MSG_INPUT_STICK_RIGHT 0x02
#define MSG_INPUT_STICK_DOWN 0x04
#define MSG_INPUT_STICK_LEFT 0x08
#define MSG_INPUT_STICK_CENTER 0x00

#define MSG_INPUT_RELEASED 0x00
#define MSG_INPUT_PRESSED 0x01
#define MSG_INPUT_HELD 0x02

#define MSG_IN_ROTARY 0x264
#define MSG_IN_ROTARY_INIT 0x277

#define MSG_IN_STATUS 0x5E7
#define MSG_STATUS_NO_INIT 0x06

#define MSG_IN_TOUCH 0xBF
#define FINGER_REMOVED 0x11
#define SINGLE_TOUCH 0x10
#define MULTI_TOUCH 0x00
#define TRIPLE_TOUCH 0x1F
#define QUAD_TOUCH 0x0F

#define MSG_IN_TOUCH_V2 0xFFFFFFBF  // for debugging only

// Outgoing
#define MSG_OUT_ROTARY_INIT 0x273
#define MSG_OUT_LIGHT 0x202
#define MSG_OUT_POLL 0x501  // or 0x563

// Functions
void iDriveInit();
void iDriveTouchpadInit();
void iDrivePoll(unsigned long milliseconds);
void iDriveLight(unsigned long milliseconds);
void decodeCanBus(unsigned long canId, uint8_t len, uint8_t buf[8]);

void do_iDrivePoll();
void do_iDriveLight();

bool isvalueinarray(int val, int *arr, int size);

#endif


--- include\key_assignments.h ---
#ifndef KEYASSIGNMENTS_H
#define KEYASSIGNMENTS_H

#define HID_KEY_A 0x04
#define HID_KEY_B 0x05
#define HID_KEY_C 0x06
#define HID_KEY_D 0x07
#define HID_KEY_E 0x08
#define HID_KEY_F 0x09
#define HID_KEY_M 0x10
#define HID_KEY_N 0x11
#define HID_KEY_O 0x12
#define HID_KEY_R 0x15
#define HID_KEY_S 0x16
#define HID_KEY_T 0x17
#define HID_KEY_U 0x18
#define HID_KEY_DD 0x07  // 'd' repeated from above
#define HID_KEY_L 0x0F
#define HID_KEY_ENTER 0x28
#define HID_KEY_ESC 0x29
#define HID_KEY_BSPACE 0x2A
#define HID_KEY_LEFT_ARROW 0x50
#define HID_KEY_RIGHT_ARROW 0x4F
#define HID_KEY_UP_ARROW 0x52
#define HID_KEY_DOWN_ARROW 0x51
#define HID_KEY_VOLUP 0x80    // or Consumer usage
#define HID_KEY_VOLDOWN 0x81  // or Consumer usage

/*=========================================================================*/
/*           Here are the symbolic names used by decodeCanBus              */
/*=========================================================================*/

// For iDrive Buttons
#define KEY_MENU_KB HID_KEY_M
#define KEY_BACK_KB HID_KEY_B
#define KEY_OPTION_KB HID_KEY_O
#define KEY_RADIO_KB HID_KEY_R
#define KEY_CD_KB HID_KEY_C
#define KEY_NAV_KB HID_KEY_N
#define KEY_TEL_KB HID_KEY_T

// Joystick movements
#define KEY_CENTER_KB HID_KEY_S
#define KEY_UP_KB HID_KEY_U
#define KEY_DOWN_KB HID_KEY_D  // or HID_KEY_DD
#define KEY_LEFT_KB HID_KEY_L
#define KEY_RIGHT_KB HID_KEY_R  // But conflict with 'r'?

// Rotations
#define KEY_ROTATE_PLUS_KB HID_KEY_VOLUP
#define KEY_ROTATE_MINUS_KB HID_KEY_VOLDOWN

// For mouse buttons, define if needed:
#define MOUSE_BTN_LEFT 0x01
#define MOUSE_BTN_RIGHT 0x02
#define MOUSE_BTN_MIDDLE 0x04

#endif


--- include\settings.h ---
#ifndef SETTINGS_H
#define SETTINGS_H

/*=========================================================================*/
/*  Board & Feature Settings                                               */
/*=========================================================================*/

#define ANDROID  // Android mode enabled - uses Android-specific media keys

// iDrive Joystick can be used as arrow keys or as mouse
#define iDriveJoystickAsMouse  // Enable for mouse mode, comment out for arrow keys

#define MOUSE_V1  // Touchpad data format version
// #define MOUSE_V2

/*=========================================================================*/
/*  iDrive Timing & Behavior                                               */
/*=========================================================================*/

const long iDrivePollTime          = 500;    // ms - how often to poll iDrive
const long iDriveInitLightTime     = 1000;   // ms - light on during init
const long iDriveLightTime         = 10000;  // ms - light keepalive interval
const long controllerCoolDown      = 750;    // ms - wait before ready
const int  TouchpadInitIgnoreCount = 2;      // Ignore first N touchpad messages
const int  min_mouse_travel        = 5;      // Minimum movement threshold

#define JOYSTICK_MOVE_STEP 30  // Mouse movement step for joystick

// Android-specific button mappings:
// MENU button -> Android Menu
// BACK button -> Android Back
// OPTION button -> Play/Pause
// RADIO button -> Previous track
// CD button -> Next track
// NAV button -> Android Home
// TEL button -> Android Search
// Rotary knob -> Volume up/down
// Touchpad -> Mouse cursor
// Joystick center -> Mouse click (or Enter key)

/*=========================================================================*/
/*  USB Device Settings                                                    */
/*=========================================================================*/

// USB descriptors - these will appear in Android device manager
#define USB_VENDOR_ID    0x1234  // Change to your vendor ID if you have one
#define USB_PRODUCT_ID   0x5678  // Change to your product ID
#define USB_MANUFACTURER "BMW"
#define USB_PRODUCT      "iDrive Controller"
#define USB_SERIAL_NUM   "123456"

/*=========================================================================*/
/*  Mouse/Touchpad Sensitivity                                             */
/*=========================================================================*/

// V1 touchpad settings (8-bit signed coordinates)
const int8_t mouse_low_range    = -128;
const int8_t mouse_high_range   = 127;
const int8_t mouse_center_range = 0;
const float  powerValue         = 1.4;

// V2 touchpad settings (16-bit unsigned coordinates)
const int mouse_low_range_v2    = 0;
const int mouse_high_range_v2   = 510;
const int mouse_center_range_v2 = mouse_high_range_v2 / 2;

// Sensitivity multipliers - adjust these for your preference
const int x_multiplier = 15;  // Horizontal sensitivity (higher = faster)
const int y_multiplier = 15;  // Vertical sensitivity (higher = faster)

/*=========================================================================*/
/*  Debugging                                                              */
/*=========================================================================*/

#define SERIAL_DEBUG
#define DEBUG_CanResponse
// #define DEBUG_Keys
// #define DEBUG_TouchPad
// #define DEBUG_SpecificCanID
// #define DEBUG_ID 0xBF

// CAN IDs to ignore in debug output (reduces log spam)
// Defined in idrive.cpp
extern int ignored_responses[];

/*=========================================================================*/
/*  Light Control                                                          */
/*=========================================================================*/

// Which button turns off the backlight (set to 0 to disable)
#define LIGHT_OFF_BUTTON MSG_INPUT_BUTTON_OPTION

// Auto-dim settings
#define AUTO_DIM_ENABLED    1
#define AUTO_DIM_TIMEOUT    30000  // ms - dim after 30 seconds of inactivity
#define AUTO_DIM_BRIGHTNESS 50     // % - dimmed brightness level

#endif  // SETTINGS_H

--- include\tusb_config.h ---
#ifndef TUSB_CONFIG_H
#define TUSB_CONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

//--------------------------------------------------------------------
// COMMON CONFIGURATION
//--------------------------------------------------------------------

// defined by compiler flag for flexibility
#ifndef CFG_TUSB_MCU
    #define CFG_TUSB_MCU OPT_MCU_ESP32S3
#endif

#ifndef CFG_TUSB_OS
    #define CFG_TUSB_OS OPT_OS_FREERTOS
#endif

#ifndef CFG_TUSB_DEBUG
    #define CFG_TUSB_DEBUG 0
#endif

// Enable Device stack
#define CFG_TUD_ENABLED 1

// CFG_TUSB_DEBUG is defined by compiler in DEBUG build
// #define CFG_TUSB_DEBUG           0

/* USB DMA on some MCUs can only access a specific SRAM region with restriction
 * on alignment. Tinyusb use follows macros to declare transferring memory so
 * that they can be put into those specific section. e.g
 * - CFG_TUSB_MEM SECTION : __attribute__ (( section(".usb_ram") ))
 * - CFG_TUSB_MEM_ALIGN   : __attribute__ ((aligned(4)))
 */
#ifndef CFG_TUSB_MEM_SECTION
    #define CFG_TUSB_MEM_SECTION
#endif

#ifndef CFG_TUSB_MEM_ALIGN
    #define CFG_TUSB_MEM_ALIGN __attribute__((aligned(4)))
#endif

//--------------------------------------------------------------------
// DEVICE CONFIGURATION
//--------------------------------------------------------------------

#ifndef CFG_TUD_ENDPOINT0_SIZE
    #define CFG_TUD_ENDPOINT0_SIZE 64
#endif

//------------- CLASS -------------//
#define CFG_TUD_HID    1
#define CFG_TUD_CDC    0
#define CFG_TUD_MSC    0
#define CFG_TUD_MIDI   0
#define CFG_TUD_VENDOR 0

// HID buffer size Should be sufficient to hold ID (if any) + Data
#define CFG_TUD_HID_EP_BUFSIZE 16

// CDC FIFO size of TX and RX
#define CFG_TUD_CDC_RX_BUFSIZE (TUD_OPT_HIGH_SPEED ? 512 : 64)
#define CFG_TUD_CDC_TX_BUFSIZE (TUD_OPT_HIGH_SPEED ? 512 : 64)

// CDC Endpoint transfer buffer size, more is faster
#define CFG_TUD_CDC_EP_BUFSIZE (TUD_OPT_HIGH_SPEED ? 512 : 64)

// MSC Buffer size of Device Mass storage
#define CFG_TUD_MSC_EP_BUFSIZE 512

#ifdef __cplusplus
}
#endif

#endif /* TUSB_CONFIG_H */

--- include\usb_hid_device.h ---
#ifndef USB_HID_DEVICE_H
#define USB_HID_DEVICE_H

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// Initialize USB HID device
void usb_hid_device_init(void);

// Keyboard functions
void usb_hid_keyboard_press(uint8_t keycode);
void usb_hid_keyboard_release(uint8_t keycode);
void usb_hid_keyboard_press_and_release(uint8_t keycode);

// Media key functions
void usb_hid_media_key_press(uint8_t keycode);
void usb_hid_media_key_release(uint8_t keycode);
void usb_hid_media_key_press_and_release(uint8_t keycode);

// Mouse functions
void usb_hid_mouse_move(int8_t x, int8_t y);
void usb_hid_mouse_button_press(uint8_t button);
void usb_hid_mouse_button_release(uint8_t button);
void usb_hid_mouse_click(uint8_t button);
void usb_hid_mouse_scroll(int8_t wheel);

// Check if USB is connected
bool usb_hid_is_connected(void);

// Standard keyboard keycodes
#define HID_KEY_A 0x04
#define HID_KEY_B 0x05
#define HID_KEY_C 0x06
#define HID_KEY_D 0x07
#define HID_KEY_E 0x08
#define HID_KEY_F 0x09
#define HID_KEY_G 0x0A
#define HID_KEY_H 0x0B
#define HID_KEY_I 0x0C
#define HID_KEY_J 0x0D
#define HID_KEY_K 0x0E
#define HID_KEY_L 0x0F
#define HID_KEY_M 0x10
#define HID_KEY_N 0x11
#define HID_KEY_O 0x12
#define HID_KEY_P 0x13
#define HID_KEY_Q 0x14
#define HID_KEY_R 0x15
#define HID_KEY_S 0x16
#define HID_KEY_T 0x17
#define HID_KEY_U 0x18
#define HID_KEY_V 0x19
#define HID_KEY_W 0x1A
#define HID_KEY_X 0x1B
#define HID_KEY_Y 0x1C
#define HID_KEY_Z 0x1D

#define HID_KEY_1 0x1E
#define HID_KEY_2 0x1F
#define HID_KEY_3 0x20
#define HID_KEY_4 0x21
#define HID_KEY_5 0x22
#define HID_KEY_6 0x23
#define HID_KEY_7 0x24
#define HID_KEY_8 0x25
#define HID_KEY_9 0x26
#define HID_KEY_0 0x27

#define HID_KEY_ENTER 0x28
#define HID_KEY_ESC 0x29
#define HID_KEY_BACKSPACE 0x2A
#define HID_KEY_TAB 0x2B
#define HID_KEY_SPACE 0x2C

#define HID_KEY_F1 0x3A
#define HID_KEY_F2 0x3B
#define HID_KEY_F3 0x3C
#define HID_KEY_F4 0x3D
#define HID_KEY_F5 0x3E
#define HID_KEY_F6 0x3F
#define HID_KEY_F7 0x40
#define HID_KEY_F8 0x41
#define HID_KEY_F9 0x42
#define HID_KEY_F10 0x43
#define HID_KEY_F11 0x44
#define HID_KEY_F12 0x45

#define HID_KEY_RIGHT 0x4F
#define HID_KEY_LEFT 0x50
#define HID_KEY_DOWN 0x51
#define HID_KEY_UP 0x52

// Media control keycodes (Consumer Page)
#define HID_MEDIA_PLAY_PAUSE 0x00CD
#define HID_MEDIA_STOP 0x00B7
#define HID_MEDIA_NEXT_TRACK 0x00B5
#define HID_MEDIA_PREV_TRACK 0x00B6
#define HID_MEDIA_VOLUME_UP 0x00E9
#define HID_MEDIA_VOLUME_DOWN 0x00EA
#define HID_MEDIA_MUTE 0x00E2
#define HID_MEDIA_BASS_BOOST 0x00E5
#define HID_MEDIA_LOUDNESS 0x00E7
#define HID_MEDIA_BASS_UP 0x0152
#define HID_MEDIA_BASS_DOWN 0x0153
#define HID_MEDIA_TREBLE_UP 0x0154
#define HID_MEDIA_TREBLE_DOWN 0x0155

// Android specific media keys
#define HID_ANDROID_BACK 0x0224    // AC Back
#define HID_ANDROID_HOME 0x0223    // AC Home
#define HID_ANDROID_MENU 0x0040    // Menu key
#define HID_ANDROID_SEARCH 0x0221  // AC Search

// Mouse buttons
#define HID_MOUSE_BUTTON_LEFT 0x01
#define HID_MOUSE_BUTTON_RIGHT 0x02
#define HID_MOUSE_BUTTON_MIDDLE 0x04

#ifdef __cplusplus
}
#endif

#endif  // USB_HID_DEVICE_H

--- include\variables.h ---
#ifndef VARIABLES_H
#define VARIABLES_H

#include <cstddef>
#include <cstdint>
/*==========================================================================*/
/* Shared Global Variables (from original)                                  */
/*==========================================================================*/

// CAN settings
extern unsigned long previousMillis;
extern unsigned long CoolDownMillis;
extern int init_can_count;
extern const int max_can_init_attempts;
extern bool RotaryInitSuccess;
extern bool PollInit;
extern bool TouchpadInitDone;
extern bool LightInitDone;
extern bool RotaryInitPositionSet;
extern bool controllerReady;
extern bool touching;
extern bool rotaryDisabled;

// iDrive or user-specified states
extern bool iDriveLightOn;

// Rotary position for decoding
extern unsigned int rotaryposition;

// For advanced mouse handling
extern int PreviousX;
extern int PreviousY;
extern int ResultX;
extern int ResultY;
extern int TouchpadInitIgnoreCounter;

// mouse ranges
extern const int8_t mouse_low_range;
extern const int8_t mouse_high_range;
extern const int8_t mouse_center_range;
extern const float powerValue;

extern const int mouse_low_range_v2;
extern const int mouse_high_range_v2;
extern const int mouse_center_range_v2;
extern const int x_multiplier;
extern const int y_multiplier;

// Key state array
extern uint8_t stati[256];

#endif


--- src\CMakeLists.txt ---
# This file was automatically generated for projects
# without default 'CMakeLists.txt' file.

FILE(GLOB_RECURSE app_sources ${CMAKE_SOURCE_DIR}/src/*.*)

idf_component_register(SRCS ${app_sources})


--- src\idrive.cpp ---
#include "idrive.h"

#include <math.h>
#include <stdint.h>
#include <string.h>

#include "driver/twai.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "key_assignments.h"
#include "settings.h"
#include "usb_hid_device.h"
#include "variables.h"

static const char *TAG = "IDRIVE";

// CAN IDs to ignore in debug output
int       ignored_responses[]    = {0x264, 0x267, 0x277, 0x567, 0x5E7, 0xBF};
const int ignored_responses_size = sizeof(ignored_responses) / sizeof(int);

// Helper to constrain value - moved before usage
static int constrain(int value, int min, int max)
{
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

// Helper function to send a CAN frame
static void sendCANFrame(uint32_t canId, bool extended, uint8_t length, uint8_t *data)
{
    twai_message_t message;
    message.identifier       = canId;
    message.extd             = extended ? 1 : 0;
    message.data_length_code = length;
    for (int i = 0; i < length; i++) {
        message.data[i] = data[i];
    }

    esp_err_t ret = twai_transmit(&message, pdMS_TO_TICKS(50));
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "CAN transmit failed: %s", esp_err_to_name(ret));
    }
}

/*=========================================================================*/
/* iDrive Functions                                                        */
/*=========================================================================*/

void iDriveInit()
{
    // Example: ID 273, Data: 1D E1 00 F0 FF 7F DE 04
    uint8_t buf[8] = {0x1D, 0xE1, 0x00, 0xF0, 0xFF, 0x7F, 0xDE, 0x04};
    sendCANFrame(MSG_OUT_ROTARY_INIT, false, 8, buf);

    RotaryInitPositionSet = false;
    ESP_LOGI(TAG, "Sent iDriveInit frame");
}

void iDriveTouchpadInit()
{
    // Example: ID BF, Data: 21 00 00 00 11 00 00 00
    uint8_t buf[8] = {0x21, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00};
    sendCANFrame(MSG_IN_TOUCH, false, 8, buf);
    ESP_LOGI(TAG, "Sent iDriveTouchpadInit frame");
}

void do_iDriveLight()
{
    // ID 202 => 2 FD 0 => on, 2 FE 0 => off
    uint8_t buf[3];
    buf[0] = 0x02;
    buf[1] = (iDriveLightOn) ? 0xFD : 0xFE;
    buf[2] = 0x00;
    sendCANFrame(MSG_OUT_LIGHT, false, 3, buf);
}

void iDriveLight(unsigned long milliseconds)
{
    static uint32_t lastLight = 0;
    uint32_t        now       = (uint32_t) (esp_timer_get_time() / 1000ULL);

    if (now - lastLight >= milliseconds) {
        lastLight = now;
        do_iDriveLight();
    }
}

void do_iDrivePoll()
{
    // ID 501 => 1 0 0 0 0 0 0 0
    uint8_t buf[8] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    sendCANFrame(MSG_OUT_POLL, false, 8, buf);
}

void iDrivePoll(unsigned long milliseconds)
{
    static uint32_t lastPing = 0;
    uint32_t        now      = (uint32_t) (esp_timer_get_time() / 1000ULL);

    if (now - lastPing >= milliseconds) {
        lastPing = now;
#if defined(SERIAL_DEBUG) && defined(DEBUG_CanResponse)
        ESP_LOGI(TAG, "iDrive Polling");
#endif
        do_iDrivePoll();
    }
}

/*=========================================================================*/
/* Helper functions for button/joystick handling                          */
/*=========================================================================*/

static void handleButton(uint8_t button, uint8_t state)
{
    if (!controllerReady || !usb_hid_is_connected())
        return;

    // Map iDrive buttons to Android media keys
    uint16_t mediaKey    = 0;
    uint8_t  keyboardKey = 0;

    switch (button) {
        case MSG_INPUT_BUTTON_MENU:
            mediaKey = HID_ANDROID_MENU;  // Android Menu key
            break;
        case MSG_INPUT_BUTTON_BACK:
            mediaKey = HID_ANDROID_BACK;  // Android Back key
            break;
        case MSG_INPUT_BUTTON_OPTION:
            mediaKey = HID_MEDIA_PLAY_PAUSE;  // Play/Pause
            break;
        case MSG_INPUT_BUTTON_RADIO:
            mediaKey = HID_MEDIA_PREV_TRACK;  // Previous track
            break;
        case MSG_INPUT_BUTTON_CD:
            mediaKey = HID_MEDIA_NEXT_TRACK;  // Next track
            break;
        case MSG_INPUT_BUTTON_NAV:
            mediaKey = HID_ANDROID_HOME;  // Android Home
            break;
        case MSG_INPUT_BUTTON_TEL:
            mediaKey = HID_ANDROID_SEARCH;  // Android Search
            break;
    }

    if (state == MSG_INPUT_PRESSED) {
        if (mediaKey) {
            ESP_LOGI(TAG, "Button pressed: 0x%02X -> Media key: 0x%04X", button, mediaKey);
            usb_hid_media_key_press(mediaKey);
        } else if (keyboardKey) {
            ESP_LOGI(TAG, "Button pressed: 0x%02X -> Keyboard key: 0x%02X", button, keyboardKey);
            usb_hid_keyboard_press(keyboardKey);
        }
    } else if (state == MSG_INPUT_RELEASED) {
        if (mediaKey) {
            ESP_LOGI(TAG, "Button released: 0x%02X", button);
            usb_hid_media_key_release(mediaKey);
        } else if (keyboardKey) {
            ESP_LOGI(TAG, "Button released: 0x%02X", button);
            usb_hid_keyboard_release(keyboardKey);
        }
    }
}

static void handleJoystick(uint8_t direction, uint8_t state)
{
    if (!controllerReady || !usb_hid_is_connected())
        return;

#ifdef iDriveJoystickAsMouse
    // Joystick as mouse movement
    if (state == MSG_INPUT_PRESSED || state == MSG_INPUT_HELD) {
        int8_t x = 0, y = 0;

        if (direction & MSG_INPUT_STICK_UP)
            y = -JOYSTICK_MOVE_STEP;
        if (direction & MSG_INPUT_STICK_DOWN)
            y = JOYSTICK_MOVE_STEP;
        if (direction & MSG_INPUT_STICK_LEFT)
            x = -JOYSTICK_MOVE_STEP;
        if (direction & MSG_INPUT_STICK_RIGHT)
            x = JOYSTICK_MOVE_STEP;

        if (x != 0 || y != 0) {
            ESP_LOGI(TAG, "Joystick move: x=%d, y=%d", x, y);
            usb_hid_mouse_move(x, y);
        }
    }

    // Center press as left click
    if (direction == MSG_INPUT_STICK_CENTER) {
        if (state == MSG_INPUT_PRESSED) {
            ESP_LOGI(TAG, "Joystick center pressed - left click");
            usb_hid_mouse_button_press(HID_MOUSE_BUTTON_LEFT);
        } else if (state == MSG_INPUT_RELEASED) {
            ESP_LOGI(TAG, "Joystick center released");
            usb_hid_mouse_button_release(HID_MOUSE_BUTTON_LEFT);
        }
    }
#else
    // Joystick as arrow keys
    uint8_t key = 0;

    if (direction & MSG_INPUT_STICK_UP)
        key = HID_KEY_UP;
    else if (direction & MSG_INPUT_STICK_DOWN)
        key = HID_KEY_DOWN;
    else if (direction & MSG_INPUT_STICK_LEFT)
        key = HID_KEY_LEFT;
    else if (direction & MSG_INPUT_STICK_RIGHT)
        key = HID_KEY_RIGHT;
    else if (direction == MSG_INPUT_STICK_CENTER)
        key = HID_KEY_ENTER;

    if (key) {
        if (state == MSG_INPUT_PRESSED) {
            ESP_LOGI(TAG, "Joystick arrow key pressed: 0x%02X", key);
            usb_hid_keyboard_press(key);
        } else if (state == MSG_INPUT_RELEASED) {
            ESP_LOGI(TAG, "Joystick arrow key released: 0x%02X", key);
            usb_hid_keyboard_release(key);
        }
    }
#endif
}

static void handleRotary(int8_t steps)
{
    if (!controllerReady || !usb_hid_is_connected() || rotaryDisabled)
        return;

    // Use rotary for volume control
    if (steps > 0) {
        for (int i = 0; i < steps; i++) {
            ESP_LOGI(TAG, "Rotary right - Volume up");
            usb_hid_media_key_press_and_release(HID_MEDIA_VOLUME_UP);
            vTaskDelay(pdMS_TO_TICKS(20));
        }
    } else if (steps < 0) {
        for (int i = 0; i < -steps; i++) {
            ESP_LOGI(TAG, "Rotary left - Volume down");
            usb_hid_media_key_press_and_release(HID_MEDIA_VOLUME_DOWN);
            vTaskDelay(pdMS_TO_TICKS(20));
        }
    }
}

static void handleTouchpad(int16_t x, int16_t y, uint8_t touchType)
{
    if (!controllerReady || !usb_hid_is_connected() || !TouchpadInitDone)
        return;

    static int16_t lastX = 0, lastY = 0;
    static bool    wasTracking = false;

    if (touchType == FINGER_REMOVED) {
        touching    = false;
        wasTracking = false;
        ESP_LOGI(TAG, "Touchpad: finger removed");
        return;
    }

    touching = true;

    if (!wasTracking) {
        // First touch - just save position
        lastX       = x;
        lastY       = y;
        wasTracking = true;
        ESP_LOGI(TAG, "Touchpad: touch started at x=%d, y=%d", x, y);
        return;
    }

    // Calculate movement delta
    int16_t deltaX = x - lastX;
    int16_t deltaY = y - lastY;

    // Apply threshold to avoid jitter
    if (abs(deltaX) < min_mouse_travel)
        deltaX = 0;
    if (abs(deltaY) < min_mouse_travel)
        deltaY = 0;

    if (deltaX != 0 || deltaY != 0) {
        // Scale movement for better feel
        int8_t mouseX = constrain(deltaX * x_multiplier / 10, -127, 127);
        int8_t mouseY = constrain(deltaY * y_multiplier / 10, -127, 127);

        ESP_LOGI(TAG, "Touchpad move: x=%d, y=%d (delta: %d, %d)", mouseX, mouseY, deltaX, deltaY);
        usb_hid_mouse_move(mouseX, mouseY);

        lastX = x;
        lastY = y;
    }
}

/*=========================================================================*/
/*  decodeCanBus() - Process CAN messages and trigger USB HID events      */
/*=========================================================================*/

bool isvalueinarray(int val, int *arr, int size)
{
    for (int i = 0; i < size; i++) {
        if (arr[i] == val)
            return true;
    }
    return false;
}

void decodeCanBus(unsigned long canId, uint8_t len, uint8_t *buf)
{
#ifdef DEBUG_CanResponse
    if (!isvalueinarray(canId, ignored_responses, ignored_responses_size)) {
        ESP_LOGI(TAG, "CAN ID: 0x%03lX, DLC:%d, Data:", canId, len);
        for (int i = 0; i < len; i++) {
            printf("%02X ", buf[i]);
        }
        printf("\n");
    }
#endif

    // Process different CAN messages
    switch (canId) {
        case MSG_IN_INPUT: {  // 0x267 - Buttons and joystick
            if (len >= 3) {
                uint8_t type  = buf[0];
                uint8_t value = buf[1];
                uint8_t state = buf[2];

                if (type == MSG_INPUT_BUTTON) {
                    handleButton(value, state);
                } else if (type == MSG_INPUT_STICK || type == MSG_INPUT_CENTER) {
                    handleJoystick(value, state);
                }
            }
            break;
        }

        case MSG_IN_ROTARY: {  // 0x264 - Rotary encoder
            if (len >= 2 && RotaryInitPositionSet) {
                unsigned int newPosition = (buf[0] << 8) | buf[1];
                int          delta       = (int) newPosition - (int) rotaryposition;

                // Handle wraparound
                if (delta > 32768)
                    delta -= 65536;
                else if (delta < -32768)
                    delta += 65536;

                if (delta != 0) {
                    handleRotary(delta);
                    rotaryposition = newPosition;
                }
            } else if (!RotaryInitPositionSet && len >= 2) {
                // Set initial position
                rotaryposition        = (buf[0] << 8) | buf[1];
                RotaryInitPositionSet = true;
                ESP_LOGI(TAG, "Rotary initial position: %u", rotaryposition);
            }
            break;
        }

        case MSG_IN_TOUCH: {  // 0xBF - Touchpad
            if (len >= 8) {
                // Touchpad data format varies by version
                if (TouchpadInitIgnoreCounter < TouchpadInitIgnoreCount) {
                    TouchpadInitIgnoreCounter++;
                    TouchpadInitDone = true;
                    ESP_LOGI(TAG, "Touchpad init progress: %d/%d", TouchpadInitIgnoreCounter,
                             TouchpadInitIgnoreCount);
                    break;
                }

#ifdef MOUSE_V1
                // V1 format: touch type at buf[1], coordinates in specific positions
                uint8_t touchType = buf[1];

                if (touchType == SINGLE_TOUCH) {
                    int16_t x = (int8_t) buf[4];  // Signed 8-bit
                    int16_t y = (int8_t) buf[5];  // Signed 8-bit
                    handleTouchpad(x, y, touchType);
                } else if (touchType == FINGER_REMOVED) {
                    handleTouchpad(0, 0, touchType);
                }
#else
                // V2 format: 16-bit coordinates
                uint8_t touchType = buf[6];

                if (touchType != FINGER_REMOVED) {
                    int16_t x = (buf[2] << 8) | buf[3];
                    int16_t y = (buf[4] << 8) | buf[5];
                    handleTouchpad(x, y, touchType);
                } else {
                    handleTouchpad(0, 0, touchType);
                }
#endif
            }
            break;
        }

        case MSG_IN_ROTARY_INIT: {  // 0x277
            ESP_LOGI(TAG, "Rotary Init Success");
            RotaryInitSuccess = true;
            break;
        }

        case MSG_IN_STATUS: {  // 0x5E7
            if (buf[4] == MSG_STATUS_NO_INIT) {
                ESP_LOGW(TAG, "iDrive lost init - reinitializing");
                RotaryInitSuccess         = false;
                LightInitDone             = false;
                TouchpadInitDone          = false;
                previousMillis            = 0;
                CoolDownMillis            = 0;
                TouchpadInitIgnoreCounter = 0;
                controllerReady           = false;

                // Reinitialize
                iDriveInit();
                iDriveTouchpadInit();
            }
            break;
        }
    }
}

--- src\main.cpp ---
#include <cstdio>

#include "driver/twai.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "idrive.h"
#include "settings.h"
#include "usb_hid_device.h"
#include "variables.h"

#define RX_PIN 4
#define TX_PIN 5

static const char *TAG = "MAIN";

// Helper to get current time in milliseconds (similar to Arduino millis())
static uint32_t getMillis()
{
    return (uint32_t) (esp_timer_get_time() / 1000ULL);
}

static void setupTWAI()
{
    // For 500 kbps
    twai_general_config_t g_config = {};
    g_config.mode                  = TWAI_MODE_NORMAL;
    g_config.tx_io                 = (gpio_num_t) TX_PIN;
    g_config.rx_io                 = (gpio_num_t) RX_PIN;
    g_config.clkout_io             = GPIO_NUM_NC;
    g_config.bus_off_io            = GPIO_NUM_NC;
    g_config.tx_queue_len          = 5;
    g_config.rx_queue_len          = 5;
    g_config.alerts_enabled        = TWAI_ALERT_NONE;
    g_config.clkout_divider        = 0;
    g_config.intr_flags            = ESP_INTR_FLAG_LEVEL1;

    twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();

    twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

    esp_err_t err = twai_driver_install(&g_config, &t_config, &f_config);
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "TWAI driver installed");
    } else {
        ESP_LOGE(TAG, "TWAI driver installation failed: %s", esp_err_to_name(err));
        return;
    }

    err = twai_start();
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "TWAI driver started");
    } else {
        ESP_LOGE(TAG, "TWAI driver start failed: %s", esp_err_to_name(err));
    }
}

extern "C" void app_main(void)
{
    ESP_LOGI(TAG, "ESP-IDF iDrive Project - Starting up...");

    // Initialize global variables
    previousMillis = getMillis();

    // Initialize USB HID device
    usb_hid_device_init();
    ESP_LOGI(TAG, "USB HID device initialized");

    // Small delay to let USB enumerate
    vTaskDelay(pdMS_TO_TICKS(1000));

    setupTWAI();

    iDriveInit();
    iDriveTouchpadInit();

    // Enter main loop
    while (true) {
        // If we haven't done so, check if controller can be marked ready
        if (!controllerReady && RotaryInitSuccess && TouchpadInitDone) {
            if (CoolDownMillis == 0)
                CoolDownMillis = getMillis();
            if (getMillis() - CoolDownMillis > controllerCoolDown) {
                controllerReady = true;
                ESP_LOGI(TAG, "iDrive controller ready!");
            }
        }

        // Receive any incoming CAN frames (non-blocking)
        twai_message_t message;
        esp_err_t      ret = twai_receive(&message, 0);  // timeout=0 => non-blocking
        if (ret == ESP_OK) {
            // decode - this is where button presses and touchpad events are handled
            decodeCanBus(message.identifier, message.data_length_code, message.data);
        }

        // Periodic tasks
        uint32_t now = getMillis();

        // Light init logic
        if (!LightInitDone) {
            if (previousMillis == 0)
                previousMillis = now;
            if (now - previousMillis > iDriveInitLightTime) {
                LightInitDone = true;
            } else {
                do_iDriveLight();
            }
        }

        // iDrive Poll
        iDrivePoll(iDrivePollTime);

        // iDrive Light keepalive
        iDriveLight(iDriveLightTime);

        // Tiny delay so we don't hog the CPU
        vTaskDelay(pdMS_TO_TICKS(5));
    }
}

--- src\usb_hid_device.c ---
#include "usb_hid_device.h"

#include <string.h>

#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "freertos/task.h"

// ESP-IDF includes for TinyUSB

#include "class/hid/hid_device.h"
#include "tinyusb.h"

static const char *TAG = "USB_HID";

// Mutex for thread safety
static SemaphoreHandle_t hid_mutex = NULL;

// Connection state
static bool usb_connected = false;

// Report IDs
#define REPORT_ID_KEYBOARD 1
#define REPORT_ID_MOUSE    2
#define REPORT_ID_CONSUMER 3

// HID Report Descriptor for composite device (Keyboard + Mouse + Consumer Control)
static const uint8_t hid_report_descriptor[] = {
    // Keyboard
    0x05, 0x01,                // Usage Page (Generic Desktop)
    0x09, 0x06,                // Usage (Keyboard)
    0xA1, 0x01,                // Collection (Application)
    0x85, REPORT_ID_KEYBOARD,  // Report ID (1)
    0x05, 0x07,                // Usage Page (Keyboard)
    0x19, 0xE0,                // Usage Minimum (Keyboard Left Control)
    0x29, 0xE7,                // Usage Maximum (Keyboard Right GUI)
    0x15, 0x00,                // Logical Minimum (0)
    0x25, 0x01,                // Logical Maximum (1)
    0x75, 0x01,                // Report Size (1)
    0x95, 0x08,                // Report Count (8)
    0x81, 0x02,                // Input (Data,Var,Abs)
    0x95, 0x01,                // Report Count (1)
    0x75, 0x08,                // Report Size (8)
    0x81, 0x01,                // Input (Const,Array,Abs)
    0x95, 0x06,                // Report Count (6)
    0x75, 0x08,                // Report Size (8)
    0x15, 0x00,                // Logical Minimum (0)
    0x25, 0xFF,                // Logical Maximum (255)
    0x05, 0x07,                // Usage Page (Keyboard)
    0x19, 0x00,                // Usage Minimum (0)
    0x29, 0xFF,                // Usage Maximum (255)
    0x81, 0x00,                // Input (Data,Array,Abs)
    0xC0,                      // End Collection

    // Mouse
    0x05, 0x01,             // Usage Page (Generic Desktop)
    0x09, 0x02,             // Usage (Mouse)
    0xA1, 0x01,             // Collection (Application)
    0x85, REPORT_ID_MOUSE,  // Report ID (2)
    0x09, 0x01,             // Usage (Pointer)
    0xA1, 0x00,             // Collection (Physical)
    0x05, 0x09,             // Usage Page (Button)
    0x19, 0x01,             // Usage Minimum (Button 1)
    0x29, 0x05,             // Usage Maximum (Button 5)
    0x15, 0x00,             // Logical Minimum (0)
    0x25, 0x01,             // Logical Maximum (1)
    0x95, 0x05,             // Report Count (5)
    0x75, 0x01,             // Report Size (1)
    0x81, 0x02,             // Input (Data,Var,Abs)
    0x95, 0x01,             // Report Count (1)
    0x75, 0x03,             // Report Size (3)
    0x81, 0x01,             // Input (Const,Array,Abs)
    0x05, 0x01,             // Usage Page (Generic Desktop)
    0x09, 0x30,             // Usage (X)
    0x09, 0x31,             // Usage (Y)
    0x09, 0x38,             // Usage (Wheel)
    0x15, 0x81,             // Logical Minimum (-127)
    0x25, 0x7F,             // Logical Maximum (127)
    0x75, 0x08,             // Report Size (8)
    0x95, 0x03,             // Report Count (3)
    0x81, 0x06,             // Input (Data,Var,Rel)
    0xC0,                   // End Collection
    0xC0,                   // End Collection

    // Consumer Control (Media Keys)
    0x05, 0x0C,                // Usage Page (Consumer)
    0x09, 0x01,                // Usage (Consumer Control)
    0xA1, 0x01,                // Collection (Application)
    0x85, REPORT_ID_CONSUMER,  // Report ID (3)
    0x15, 0x00,                // Logical Minimum (0)
    0x25, 0x01,                // Logical Maximum (1)
    0x75, 0x01,                // Report Size (1)
    0x95, 0x10,                // Report Count (16)
    0x09, 0xB5,                // Usage (Scan Next Track)
    0x09, 0xB6,                // Usage (Scan Previous Track)
    0x09, 0xB7,                // Usage (Stop)
    0x09, 0xB8,                // Usage (Eject)
    0x09, 0xCD,                // Usage (Play/Pause)
    0x09, 0xE2,                // Usage (Mute)
    0x09, 0xE9,                // Usage (Volume Increment)
    0x09, 0xEA,                // Usage (Volume Decrement)
    0x0A, 0x23, 0x02,          // Usage (AC Home)
    0x0A, 0x24, 0x02,          // Usage (AC Back)
    0x0A, 0x21, 0x02,          // Usage (AC Search)
    0x09, 0x40,                // Usage (Menu)
    0x09, 0x30,                // Usage (Power)
    0x09, 0x32,                // Usage (Sleep)
    0x09, 0x34,                // Usage (Stand-by)
    0x09, 0x65,                // Usage (App Control Menu)
    0x81, 0x02,                // Input (Data,Var,Abs)
    0xC0                       // End Collection
};

// Report structures
typedef struct {
    uint8_t modifier;
    uint8_t reserved;
    uint8_t keycode[6];
} keyboard_report_t;

typedef struct {
    uint8_t buttons;
    int8_t  x;
    int8_t  y;
    int8_t  wheel;
} mouse_report_t;

typedef struct {
    uint16_t usage_id;
} consumer_report_t;

// Current reports
static keyboard_report_t keyboard_report = {0};
static mouse_report_t    mouse_report    = {0};

// TinyUSB callbacks
void tud_mount_cb(void)
{
    ESP_LOGI(TAG, "USB mounted");
    usb_connected = true;
}

void tud_umount_cb(void)
{
    ESP_LOGI(TAG, "USB unmounted");
    usb_connected = false;
}

void tud_suspend_cb(bool remote_wakeup_en)
{
    (void) remote_wakeup_en;
    ESP_LOGI(TAG, "USB suspended");
    usb_connected = false;
}

void tud_resume_cb(void)
{
    ESP_LOGI(TAG, "USB resumed");
    usb_connected = true;
}

// Get HID report descriptor
uint8_t const *tud_hid_descriptor_report_cb(uint8_t itf)
{
    (void) itf;
    return hid_report_descriptor;
}

// HID Get Report callback
uint16_t tud_hid_get_report_cb(uint8_t itf, uint8_t report_id, hid_report_type_t report_type,
                               uint8_t *buffer, uint16_t reqlen)
{
    (void) itf;
    (void) reqlen;
    if (report_type != HID_REPORT_TYPE_INPUT) {
        return 0;
    }

    switch (report_id) {
        case REPORT_ID_KEYBOARD:
            memcpy(buffer, &keyboard_report, sizeof(keyboard_report));
            return sizeof(keyboard_report);
        case REPORT_ID_MOUSE:
            memcpy(buffer, &mouse_report, sizeof(mouse_report));
            return sizeof(mouse_report);
        default:
            return 0;
    }
}

// HID Set Report callback (for LEDs, etc.)
void tud_hid_set_report_cb(uint8_t itf, uint8_t report_id, hid_report_type_t report_type,
                           uint8_t const *buffer, uint16_t bufsize)
{
    (void) itf;
    (void) report_id;
    (void) report_type;
    (void) buffer;
    (void) bufsize;
    // Handle LED indicators or other output reports if needed
}

// Send keyboard report
static void send_keyboard_report(void)
{
    if (usb_connected && tud_hid_ready()) {
        uint8_t report[9];
        report[0] = REPORT_ID_KEYBOARD;
        memcpy(&report[1], &keyboard_report, sizeof(keyboard_report));
        tud_hid_report(0, report, sizeof(report));
    }
}

// Send mouse report
static void send_mouse_report(void)
{
    if (usb_connected && tud_hid_ready()) {
        uint8_t report[5];
        report[0] = REPORT_ID_MOUSE;
        memcpy(&report[1], &mouse_report, sizeof(mouse_report));
        tud_hid_report(0, report, sizeof(report));
    }
}

// Send consumer report
static void send_consumer_report(uint16_t usage_id)
{
    if (usb_connected && tud_hid_ready()) {
        uint8_t report[3];
        report[0] = REPORT_ID_CONSUMER;
        report[1] = usage_id & 0xFF;
        report[2] = (usage_id >> 8) & 0xFF;
        tud_hid_report(0, report, sizeof(report));
    }
}

// USB task to handle TinyUSB events
static void usb_device_task(void *param)
{
    (void) param;
    while (1) {
        tud_task();
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

// Public functions implementation
void usb_hid_device_init(void)
{
    ESP_LOGI(TAG, "Initializing USB HID device");

    // Create mutex
    hid_mutex = xSemaphoreCreateMutex();

    // Initialize TinyUSB
    const tinyusb_config_t tusb_cfg = {
        .device_descriptor        = NULL,  // Use default descriptor
        .string_descriptor        = NULL,
        .external_phy             = false,
        .configuration_descriptor = NULL,
    };

    ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));

    // Create USB device task
    xTaskCreate(usb_device_task, "usb_device_task", 4096, NULL, 5, NULL);

    ESP_LOGI(TAG, "USB HID device initialized");
}

void usb_hid_keyboard_press(uint8_t keycode)
{
    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        // Find empty slot in keycode array
        for (int i = 0; i < 6; i++) {
            if (keyboard_report.keycode[i] == 0) {
                keyboard_report.keycode[i] = keycode;
                break;
            }
        }
        send_keyboard_report();
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_keyboard_release(uint8_t keycode)
{
    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        // Remove keycode from array
        for (int i = 0; i < 6; i++) {
            if (keyboard_report.keycode[i] == keycode) {
                keyboard_report.keycode[i] = 0;
                break;
            }
        }
        send_keyboard_report();
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_keyboard_press_and_release(uint8_t keycode)
{
    usb_hid_keyboard_press(keycode);
    vTaskDelay(pdMS_TO_TICKS(50));
    usb_hid_keyboard_release(keycode);
}

void usb_hid_media_key_press(uint8_t keycode)
{
    send_consumer_report(keycode);
}

void usb_hid_media_key_release(uint8_t keycode)
{
    (void) keycode;
    send_consumer_report(0);  // Release all consumer keys
}

void usb_hid_media_key_press_and_release(uint8_t keycode)
{
    usb_hid_media_key_press(keycode);
    vTaskDelay(pdMS_TO_TICKS(50));
    usb_hid_media_key_release(keycode);
}

void usb_hid_mouse_move(int8_t x, int8_t y)
{
    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.x = x;
        mouse_report.y = y;
        send_mouse_report();
        mouse_report.x = 0;
        mouse_report.y = 0;
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_mouse_button_press(uint8_t button)
{
    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.buttons |= button;
        send_mouse_report();
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_mouse_button_release(uint8_t button)
{
    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.buttons &= ~button;
        send_mouse_report();
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_mouse_click(uint8_t button)
{
    usb_hid_mouse_button_press(button);
    vTaskDelay(pdMS_TO_TICKS(50));
    usb_hid_mouse_button_release(button);
}

void usb_hid_mouse_scroll(int8_t wheel)
{
    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.wheel = wheel;
        send_mouse_report();
        mouse_report.wheel = 0;
        xSemaphoreGive(hid_mutex);
    }
}

bool usb_hid_is_connected(void)
{
    return usb_connected;
}

--- src\variables.cpp ---
#include "variables.h"
#include <cstddef>

// default states
unsigned long previousMillis = 0;
unsigned long CoolDownMillis = 0;
int init_can_count = 0;
const int max_can_init_attempts = 15;
bool RotaryInitSuccess = false;
bool PollInit = false;
bool TouchpadInitDone = false;
bool LightInitDone = false;
bool RotaryInitPositionSet = false;
bool controllerReady = false;
bool touching = false;
bool rotaryDisabled = false;

bool iDriveLightOn = true;

unsigned int rotaryposition = 0;

int PreviousX = 0;
int PreviousY = 0;
int ResultX = 0;
int ResultY = 0;
int TouchpadInitIgnoreCounter = 0;

const int8_t mouse_low_range = -128;
const int8_t mouse_high_range = 127;
const int8_t mouse_center_range = 0;
const float powerValue = 1.4;

const int mouse_low_range_v2 = 0;
const int mouse_high_range_v2 = 510;
const int mouse_center_range_v2 = mouse_high_range_v2 / 2;
const int x_multiplier = 2;
const int y_multiplier = 12;

// Key states
uint8_t stati[256] = {0};


