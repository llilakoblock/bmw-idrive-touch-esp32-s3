--- CMakeLists.txt ---
cmake_minimum_required(VERSION 3.16)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(idrive)

--- platformio.ini ---
[env:esp32-s3-devkitc-1]
platform = espressif32
board = esp32-s3-devkitc-1
framework = espidf

monitor_speed = 115200

board_build.cmake_extra_args = 
    -DSDKCONFIG_DEFAULTS="sdkconfig.defaults"

--- include\idrive.h ---
#ifndef IDRIVE_H
#define IDRIVE_H

#include <stdint.h>

// Incoming
#define MSG_IN_INPUT 0x267
#define MSG_INPUT_BUTTON 0xC0
#define MSG_INPUT_BUTTON_MENU 0x01
#define MSG_INPUT_BUTTON_BACK 0x02
#define MSG_INPUT_BUTTON_OPTION 0x04
#define MSG_INPUT_BUTTON_RADIO 0x08
#define MSG_INPUT_BUTTON_CD 0x10
#define MSG_INPUT_BUTTON_NAV 0x20
#define MSG_INPUT_BUTTON_TEL 0x40

#define MSG_INPUT_CENTER 0xDE
#define MSG_INPUT_STICK 0xDD
#define MSG_INPUT_STICK_UP 0x01
#define MSG_INPUT_STICK_RIGHT 0x02
#define MSG_INPUT_STICK_DOWN 0x04
#define MSG_INPUT_STICK_LEFT 0x08
#define MSG_INPUT_STICK_CENTER 0x00

#define MSG_INPUT_RELEASED 0x00
#define MSG_INPUT_PRESSED 0x01
#define MSG_INPUT_HELD 0x02

#define MSG_IN_ROTARY 0x264
#define MSG_IN_ROTARY_INIT 0x277

#define MSG_IN_STATUS 0x5E7
#define MSG_STATUS_NO_INIT 0x06

#define MSG_IN_TOUCH 0xBF
#define FINGER_REMOVED 0x11
#define SINGLE_TOUCH 0x10
#define MULTI_TOUCH 0x00
#define TRIPLE_TOUCH 0x1F
#define QUAD_TOUCH 0x0F

#define MSG_IN_TOUCH_V2 0xFFFFFFBF  // for debugging only

// Outgoing
#define MSG_OUT_ROTARY_INIT 0x273
#define MSG_OUT_LIGHT 0x202
#define MSG_OUT_POLL 0x501  // or 0x563

// Functions
void iDriveInit();
void iDriveTouchpadInit();
void iDrivePoll(unsigned long milliseconds);
void iDriveLight(unsigned long milliseconds);
void decodeCanBus(unsigned long canId, uint8_t len, uint8_t buf[8]);

void do_iDrivePoll();
void do_iDriveLight();

bool isvalueinarray(int val, int *arr, int size);

#endif


--- include\key_assignments.h ---
#ifndef KEYASSIGNMENTS_H
#define KEYASSIGNMENTS_H

#define HID_KEY_A 0x04
#define HID_KEY_B 0x05
#define HID_KEY_C 0x06
#define HID_KEY_D 0x07
#define HID_KEY_E 0x08
#define HID_KEY_F 0x09
#define HID_KEY_M 0x10
#define HID_KEY_N 0x11
#define HID_KEY_O 0x12
#define HID_KEY_R 0x15
#define HID_KEY_S 0x16
#define HID_KEY_T 0x17
#define HID_KEY_U 0x18
#define HID_KEY_DD 0x07  // 'd' repeated from above
#define HID_KEY_L 0x0F
#define HID_KEY_ENTER 0x28
#define HID_KEY_ESC 0x29
#define HID_KEY_BSPACE 0x2A
#define HID_KEY_LEFT_ARROW 0x50
#define HID_KEY_RIGHT_ARROW 0x4F
#define HID_KEY_UP_ARROW 0x52
#define HID_KEY_DOWN_ARROW 0x51
#define HID_KEY_VOLUP 0x80    // or Consumer usage
#define HID_KEY_VOLDOWN 0x81  // or Consumer usage

/*=========================================================================*/
/*           Here are the symbolic names used by decodeCanBus              */
/*=========================================================================*/

// For iDrive Buttons
#define KEY_MENU_KB HID_KEY_M
#define KEY_BACK_KB HID_KEY_B
#define KEY_OPTION_KB HID_KEY_O
#define KEY_RADIO_KB HID_KEY_R
#define KEY_CD_KB HID_KEY_C
#define KEY_NAV_KB HID_KEY_N
#define KEY_TEL_KB HID_KEY_T

// Joystick movements
#define KEY_CENTER_KB HID_KEY_S
#define KEY_UP_KB HID_KEY_U
#define KEY_DOWN_KB HID_KEY_D  // or HID_KEY_DD
#define KEY_LEFT_KB HID_KEY_L
#define KEY_RIGHT_KB HID_KEY_R  // But conflict with 'r'?

// Rotations
#define KEY_ROTATE_PLUS_KB HID_KEY_VOLUP
#define KEY_ROTATE_MINUS_KB HID_KEY_VOLDOWN

// For mouse buttons, define if needed:
#define MOUSE_BTN_LEFT 0x01
#define MOUSE_BTN_RIGHT 0x02
#define MOUSE_BTN_MIDDLE 0x04

#endif


--- include\settings.h ---
#ifndef SETTINGS_H
#define SETTINGS_H

/*=========================================================================*/
/*  Board & Feature Settings                                               */
/*=========================================================================*/

#define ANDROID  // Android mode enabled - uses Android-specific media keys

// iDrive Joystick can be used as arrow keys or as mouse
#define iDriveJoystickAsMouse  // Enable for mouse mode, comment out for arrow keys

#define MOUSE_V1  // Touchpad data format version
// #define MOUSE_V2

/*=========================================================================*/
/*  iDrive Timing & Behavior                                               */
/*=========================================================================*/

const long iDrivePollTime          = 500;    // ms - how often to poll iDrive
const long iDriveInitLightTime     = 1000;   // ms - light on during init
const long iDriveLightTime         = 10000;  // ms - light keepalive interval
const long controllerCoolDown      = 750;    // ms - wait before ready
const int  TouchpadInitIgnoreCount = 2;      // Ignore first N touchpad messages
const int  min_mouse_travel        = 5;      // Minimum movement threshold

#define JOYSTICK_MOVE_STEP 30  // Mouse movement step for joystick

// Android-specific button mappings:
// MENU button -> Android Menu
// BACK button -> Android Back
// OPTION button -> Play/Pause
// RADIO button -> Previous track
// CD button -> Next track
// NAV button -> Android Home
// TEL button -> Android Search
// Rotary knob -> Volume up/down
// Touchpad -> Mouse cursor
// Joystick center -> Mouse click (or Enter key)

/*=========================================================================*/
/*  USB Device Settings                                                    */
/*=========================================================================*/

// USB descriptors - these will appear in Android device manager
#define USB_VENDOR_ID    0x1234  // Change to your vendor ID if you have one
#define USB_PRODUCT_ID   0x5678  // Change to your product ID
#define USB_MANUFACTURER "BMW"
#define USB_PRODUCT      "iDrive Controller"
#define USB_SERIAL_NUM   "123456"

/*=========================================================================*/
/*  Mouse/Touchpad Sensitivity                                             */
/*=========================================================================*/

// V1 touchpad settings (8-bit signed coordinates)
const int8_t mouse_low_range    = -128;
const int8_t mouse_high_range   = 127;
const int8_t mouse_center_range = 0;
const float  powerValue         = 1.4;

// V2 touchpad settings (16-bit unsigned coordinates)
const int mouse_low_range_v2    = 0;
const int mouse_high_range_v2   = 510;
const int mouse_center_range_v2 = mouse_high_range_v2 / 2;

// Sensitivity multipliers - adjust these for your preference
const int x_multiplier = 15;  // Horizontal sensitivity (higher = faster)
const int y_multiplier = 15;  // Vertical sensitivity (higher = faster)

/*=========================================================================*/
/*  Debugging                                                              */
/*=========================================================================*/

#define SERIAL_DEBUG
#define DEBUG_CanResponse
// #define DEBUG_Keys
// #define DEBUG_TouchPad
// #define DEBUG_SpecificCanID
// #define DEBUG_ID 0xBF

// CAN IDs to ignore in debug output (reduces log spam)
// Defined in idrive.cpp
extern int ignored_responses[];

/*=========================================================================*/
/*  Light Control                                                          */
/*=========================================================================*/

// Which button turns off the backlight (set to 0 to disable)
#define LIGHT_OFF_BUTTON MSG_INPUT_BUTTON_OPTION

// Auto-dim settings
#define AUTO_DIM_ENABLED    1
#define AUTO_DIM_TIMEOUT    30000  // ms - dim after 30 seconds of inactivity
#define AUTO_DIM_BRIGHTNESS 50     // % - dimmed brightness level

#endif  // SETTINGS_H

--- include\tusb_config.h ---
#ifndef TUSB_CONFIG_H
#define TUSB_CONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

// Board specific
#define CFG_TUSB_MCU OPT_MCU_ESP32S3

// RHPort number used for device can be defined by board.mk, default to port 0
#define BOARD_TUD_RHPORT 0

// RHPort max operational speed can defined by board.mk
#define BOARD_TUD_MAX_SPEED OPT_MODE_DEFAULT_SPEED

// Common configuration
#define CFG_TUSB_RHPORT0_MODE (OPT_MODE_DEVICE | OPT_MODE_DEFAULT_SPEED)
#define CFG_TUSB_OS           OPT_OS_FREERTOS

// Debug
#ifndef CFG_TUSB_DEBUG
    #define CFG_TUSB_DEBUG 0
#endif

// Memory section
#ifndef CFG_TUSB_MEM_SECTION
    #define CFG_TUSB_MEM_SECTION
#endif

#ifndef CFG_TUSB_MEM_ALIGN
    #define CFG_TUSB_MEM_ALIGN __attribute__((aligned(4)))
#endif

// Device configuration
#define CFG_TUD_ENDPOINT0_SIZE 64

// Class drivers
#define CFG_TUD_HID    1
#define CFG_TUD_CDC    0
#define CFG_TUD_MSC    0
#define CFG_TUD_MIDI   0
#define CFG_TUD_VENDOR 0

// HID buffer size
#define CFG_TUD_HID_EP_BUFSIZE 64

#ifdef __cplusplus
}
#endif

#endif

--- include\usb_hid_device.h ---
#ifndef USB_HID_DEVICE_H
#define USB_HID_DEVICE_H

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// Initialize USB HID device
void usb_hid_device_init(void);

// Keyboard functions
void usb_hid_keyboard_press(uint8_t keycode);
void usb_hid_keyboard_release(uint8_t keycode);
void usb_hid_keyboard_press_and_release(uint8_t keycode);

// Media key functions
void usb_hid_media_key_press(uint8_t keycode);
void usb_hid_media_key_release(uint8_t keycode);
void usb_hid_media_key_press_and_release(uint8_t keycode);

// Mouse functions
void usb_hid_mouse_move(int8_t x, int8_t y);
void usb_hid_mouse_button_press(uint8_t button);
void usb_hid_mouse_button_release(uint8_t button);
void usb_hid_mouse_click(uint8_t button);
void usb_hid_mouse_scroll(int8_t wheel);

// Check if USB is connected
bool usb_hid_is_connected(void);

// Standard keyboard keycodes
#define HID_KEY_A 0x04
#define HID_KEY_B 0x05
#define HID_KEY_C 0x06
#define HID_KEY_D 0x07
#define HID_KEY_E 0x08
#define HID_KEY_F 0x09
#define HID_KEY_G 0x0A
#define HID_KEY_H 0x0B
#define HID_KEY_I 0x0C
#define HID_KEY_J 0x0D
#define HID_KEY_K 0x0E
#define HID_KEY_L 0x0F
#define HID_KEY_M 0x10
#define HID_KEY_N 0x11
#define HID_KEY_O 0x12
#define HID_KEY_P 0x13
#define HID_KEY_Q 0x14
#define HID_KEY_R 0x15
#define HID_KEY_S 0x16
#define HID_KEY_T 0x17
#define HID_KEY_U 0x18
#define HID_KEY_V 0x19
#define HID_KEY_W 0x1A
#define HID_KEY_X 0x1B
#define HID_KEY_Y 0x1C
#define HID_KEY_Z 0x1D

#define HID_KEY_1 0x1E
#define HID_KEY_2 0x1F
#define HID_KEY_3 0x20
#define HID_KEY_4 0x21
#define HID_KEY_5 0x22
#define HID_KEY_6 0x23
#define HID_KEY_7 0x24
#define HID_KEY_8 0x25
#define HID_KEY_9 0x26
#define HID_KEY_0 0x27

#define HID_KEY_ENTER 0x28
#define HID_KEY_ESC 0x29
#define HID_KEY_BACKSPACE 0x2A
#define HID_KEY_TAB 0x2B
#define HID_KEY_SPACE 0x2C

#define HID_KEY_F1 0x3A
#define HID_KEY_F2 0x3B
#define HID_KEY_F3 0x3C
#define HID_KEY_F4 0x3D
#define HID_KEY_F5 0x3E
#define HID_KEY_F6 0x3F
#define HID_KEY_F7 0x40
#define HID_KEY_F8 0x41
#define HID_KEY_F9 0x42
#define HID_KEY_F10 0x43
#define HID_KEY_F11 0x44
#define HID_KEY_F12 0x45

#define HID_KEY_RIGHT 0x4F
#define HID_KEY_LEFT 0x50
#define HID_KEY_DOWN 0x51
#define HID_KEY_UP 0x52

// Media control keycodes (Consumer Page)
#define HID_MEDIA_PLAY_PAUSE 0x00CD
#define HID_MEDIA_STOP 0x00B7
#define HID_MEDIA_NEXT_TRACK 0x00B5
#define HID_MEDIA_PREV_TRACK 0x00B6
#define HID_MEDIA_VOLUME_UP 0x00E9
#define HID_MEDIA_VOLUME_DOWN 0x00EA
#define HID_MEDIA_MUTE 0x00E2
#define HID_MEDIA_BASS_BOOST 0x00E5
#define HID_MEDIA_LOUDNESS 0x00E7
#define HID_MEDIA_BASS_UP 0x0152
#define HID_MEDIA_BASS_DOWN 0x0153
#define HID_MEDIA_TREBLE_UP 0x0154
#define HID_MEDIA_TREBLE_DOWN 0x0155

// Android specific media keys
#define HID_ANDROID_BACK 0x0224    // AC Back
#define HID_ANDROID_HOME 0x0223    // AC Home
#define HID_ANDROID_MENU 0x0040    // Menu key
#define HID_ANDROID_SEARCH 0x0221  // AC Search

// Mouse buttons
#define HID_MOUSE_BUTTON_LEFT 0x01
#define HID_MOUSE_BUTTON_RIGHT 0x02
#define HID_MOUSE_BUTTON_MIDDLE 0x04

#ifdef __cplusplus
}
#endif

#endif  // USB_HID_DEVICE_H

--- include\variables.h ---
#ifndef VARIABLES_H
#define VARIABLES_H

#include <cstddef>
#include <cstdint>
/*==========================================================================*/
/* Shared Global Variables (from original)                                  */
/*==========================================================================*/

// CAN settings
extern unsigned long previousMillis;
extern unsigned long CoolDownMillis;
extern int init_can_count;
extern const int max_can_init_attempts;
extern bool RotaryInitSuccess;
extern bool PollInit;
extern bool TouchpadInitDone;
extern bool LightInitDone;
extern bool RotaryInitPositionSet;
extern bool controllerReady;
extern bool touching;
extern bool rotaryDisabled;

// iDrive or user-specified states
extern bool iDriveLightOn;

// Rotary position for decoding
extern unsigned int rotaryposition;

// For advanced mouse handling
extern int PreviousX;
extern int PreviousY;
extern int ResultX;
extern int ResultY;
extern int TouchpadInitIgnoreCounter;

// mouse ranges
extern const int8_t mouse_low_range;
extern const int8_t mouse_high_range;
extern const int8_t mouse_center_range;
extern const float powerValue;

extern const int mouse_low_range_v2;
extern const int mouse_high_range_v2;
extern const int mouse_center_range_v2;
extern const int x_multiplier;
extern const int y_multiplier;

// Key state array
extern uint8_t stati[256];

#endif


--- src\CMakeLists.txt ---
idf_component_register(
    SRCS "main.cpp" "idrive.cpp" "variables.cpp" "usb_hid_device.c"
    INCLUDE_DIRS "../include"
    REQUIRES driver freertos esp_timer
)

--- src\idf_component.yml ---
dependencies:
  esp_tinyusb: "^1.0.0" # Automatically update minor releases

--- src\idrive.cpp ---
#include "idrive.h"

#include <math.h>
#include <stdint.h>
#include <string.h>

#include "driver/twai.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "key_assignments.h"
#include "settings.h"
#include "usb_hid_device.h"
#include "variables.h"

static const char *TAG = "IDRIVE";

// CAN IDs to ignore in debug output
int       ignored_responses[]    = {0x264, 0x267, 0x277, 0x567, 0x5E7, 0xBF};
const int ignored_responses_size = sizeof(ignored_responses) / sizeof(int);

// Helper to constrain value - moved before usage
static int constrain(int value, int min, int max)
{
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

// Helper function to send a CAN frame
static void sendCANFrame(uint32_t canId, bool extended, uint8_t length, uint8_t *data)
{
    twai_message_t message;
    message.identifier       = canId;
    message.extd             = extended ? 1 : 0;
    message.data_length_code = length;
    for (int i = 0; i < length; i++) {
        message.data[i] = data[i];
    }

    esp_err_t ret = twai_transmit(&message, pdMS_TO_TICKS(50));
    if (ret != ESP_OK) {
        ESP_LOGW(TAG, "CAN transmit failed: %s", esp_err_to_name(ret));
    }
}

/*=========================================================================*/
/* iDrive Functions                                                        */
/*=========================================================================*/

void iDriveInit()
{
    // Example: ID 273, Data: 1D E1 00 F0 FF 7F DE 04
    uint8_t buf[8] = {0x1D, 0xE1, 0x00, 0xF0, 0xFF, 0x7F, 0xDE, 0x04};
    sendCANFrame(MSG_OUT_ROTARY_INIT, false, 8, buf);

    RotaryInitPositionSet = false;
    ESP_LOGI(TAG, "Sent iDriveInit frame");
}

void iDriveTouchpadInit()
{
    // Example: ID BF, Data: 21 00 00 00 11 00 00 00
    uint8_t buf[8] = {0x21, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00};
    sendCANFrame(MSG_IN_TOUCH, false, 8, buf);
    ESP_LOGI(TAG, "Sent iDriveTouchpadInit frame");
}

void do_iDriveLight()
{
    // ID 202 => 2 FD 0 => on, 2 FE 0 => off
    uint8_t buf[3];
    buf[0] = 0x02;
    buf[1] = (iDriveLightOn) ? 0xFD : 0xFE;
    buf[2] = 0x00;
    sendCANFrame(MSG_OUT_LIGHT, false, 3, buf);
}

void iDriveLight(unsigned long milliseconds)
{
    static uint32_t lastLight = 0;
    uint32_t        now       = (uint32_t) (esp_timer_get_time() / 1000ULL);

    if (now - lastLight >= milliseconds) {
        lastLight = now;
        do_iDriveLight();
    }
}

void do_iDrivePoll()
{
    // ID 501 => 1 0 0 0 0 0 0 0
    uint8_t buf[8] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    sendCANFrame(MSG_OUT_POLL, false, 8, buf);
}

void iDrivePoll(unsigned long milliseconds)
{
    static uint32_t lastPing = 0;
    uint32_t        now      = (uint32_t) (esp_timer_get_time() / 1000ULL);

    if (now - lastPing >= milliseconds) {
        lastPing = now;
#if defined(SERIAL_DEBUG) && defined(DEBUG_CanResponse)
        ESP_LOGI(TAG, "iDrive Polling");
#endif
        do_iDrivePoll();
    }
}

/*=========================================================================*/
/* Helper functions for button/joystick handling                          */
/*=========================================================================*/

static void handleButton(uint8_t button, uint8_t state)
{
    if (!controllerReady || !usb_hid_is_connected())
        return;

    // Map iDrive buttons to Android media keys
    uint16_t mediaKey    = 0;
    uint8_t  keyboardKey = 0;

    switch (button) {
        case MSG_INPUT_BUTTON_MENU:
            mediaKey = HID_ANDROID_MENU;  // Android Menu key
            break;
        case MSG_INPUT_BUTTON_BACK:
            mediaKey = HID_ANDROID_BACK;  // Android Back key
            break;
        case MSG_INPUT_BUTTON_OPTION:
            mediaKey = HID_MEDIA_PLAY_PAUSE;  // Play/Pause
            break;
        case MSG_INPUT_BUTTON_RADIO:
            mediaKey = HID_MEDIA_PREV_TRACK;  // Previous track
            break;
        case MSG_INPUT_BUTTON_CD:
            mediaKey = HID_MEDIA_NEXT_TRACK;  // Next track
            break;
        case MSG_INPUT_BUTTON_NAV:
            mediaKey = HID_ANDROID_HOME;  // Android Home
            break;
        case MSG_INPUT_BUTTON_TEL:
            mediaKey = HID_ANDROID_SEARCH;  // Android Search
            break;
    }

    if (state == MSG_INPUT_PRESSED) {
        if (mediaKey) {
            ESP_LOGI(TAG, "Button pressed: 0x%02X -> Media key: 0x%04X", button, mediaKey);
            usb_hid_media_key_press(mediaKey);
        } else if (keyboardKey) {
            ESP_LOGI(TAG, "Button pressed: 0x%02X -> Keyboard key: 0x%02X", button, keyboardKey);
            usb_hid_keyboard_press(keyboardKey);
        }
    } else if (state == MSG_INPUT_RELEASED) {
        if (mediaKey) {
            ESP_LOGI(TAG, "Button released: 0x%02X", button);
            usb_hid_media_key_release(mediaKey);
        } else if (keyboardKey) {
            ESP_LOGI(TAG, "Button released: 0x%02X", button);
            usb_hid_keyboard_release(keyboardKey);
        }
    }
}

static void handleJoystick(uint8_t direction, uint8_t state)
{
    if (!controllerReady || !usb_hid_is_connected())
        return;

#ifdef iDriveJoystickAsMouse
    // Joystick as mouse movement
    if (state == MSG_INPUT_PRESSED || state == MSG_INPUT_HELD) {
        int8_t x = 0, y = 0;

        if (direction & MSG_INPUT_STICK_UP)
            y = -JOYSTICK_MOVE_STEP;
        if (direction & MSG_INPUT_STICK_DOWN)
            y = JOYSTICK_MOVE_STEP;
        if (direction & MSG_INPUT_STICK_LEFT)
            x = -JOYSTICK_MOVE_STEP;
        if (direction & MSG_INPUT_STICK_RIGHT)
            x = JOYSTICK_MOVE_STEP;

        if (x != 0 || y != 0) {
            ESP_LOGI(TAG, "Joystick move: x=%d, y=%d", x, y);
            usb_hid_mouse_move(x, y);
        }
    }

    // Center press as left click
    if (direction == MSG_INPUT_STICK_CENTER) {
        if (state == MSG_INPUT_PRESSED) {
            ESP_LOGI(TAG, "Joystick center pressed - left click");
            usb_hid_mouse_button_press(HID_MOUSE_BUTTON_LEFT);
        } else if (state == MSG_INPUT_RELEASED) {
            ESP_LOGI(TAG, "Joystick center released");
            usb_hid_mouse_button_release(HID_MOUSE_BUTTON_LEFT);
        }
    }
#else
    // Joystick as arrow keys
    uint8_t key = 0;

    if (direction & MSG_INPUT_STICK_UP)
        key = HID_KEY_UP;
    else if (direction & MSG_INPUT_STICK_DOWN)
        key = HID_KEY_DOWN;
    else if (direction & MSG_INPUT_STICK_LEFT)
        key = HID_KEY_LEFT;
    else if (direction & MSG_INPUT_STICK_RIGHT)
        key = HID_KEY_RIGHT;
    else if (direction == MSG_INPUT_STICK_CENTER)
        key = HID_KEY_ENTER;

    if (key) {
        if (state == MSG_INPUT_PRESSED) {
            ESP_LOGI(TAG, "Joystick arrow key pressed: 0x%02X", key);
            usb_hid_keyboard_press(key);
        } else if (state == MSG_INPUT_RELEASED) {
            ESP_LOGI(TAG, "Joystick arrow key released: 0x%02X", key);
            usb_hid_keyboard_release(key);
        }
    }
#endif
}

static void handleRotary(int8_t steps)
{
    if (!controllerReady || !usb_hid_is_connected() || rotaryDisabled)
        return;

    // Use rotary for volume control
    if (steps > 0) {
        for (int i = 0; i < steps; i++) {
            ESP_LOGI(TAG, "Rotary right - Volume up");
            usb_hid_media_key_press_and_release(HID_MEDIA_VOLUME_UP);
            vTaskDelay(pdMS_TO_TICKS(20));
        }
    } else if (steps < 0) {
        for (int i = 0; i < -steps; i++) {
            ESP_LOGI(TAG, "Rotary left - Volume down");
            usb_hid_media_key_press_and_release(HID_MEDIA_VOLUME_DOWN);
            vTaskDelay(pdMS_TO_TICKS(20));
        }
    }
}

static void handleTouchpad(int16_t x, int16_t y, uint8_t touchType)
{
    if (!controllerReady || !usb_hid_is_connected() || !TouchpadInitDone)
        return;

    static int16_t lastX = 0, lastY = 0;
    static bool    wasTracking = false;

    if (touchType == FINGER_REMOVED) {
        touching    = false;
        wasTracking = false;
        ESP_LOGI(TAG, "Touchpad: finger removed");
        return;
    }

    touching = true;

    if (!wasTracking) {
        // First touch - just save position
        lastX       = x;
        lastY       = y;
        wasTracking = true;
        ESP_LOGI(TAG, "Touchpad: touch started at x=%d, y=%d", x, y);
        return;
    }

    // Calculate movement delta
    int16_t deltaX = x - lastX;
    int16_t deltaY = y - lastY;

    // Apply threshold to avoid jitter
    if (abs(deltaX) < min_mouse_travel)
        deltaX = 0;
    if (abs(deltaY) < min_mouse_travel)
        deltaY = 0;

    if (deltaX != 0 || deltaY != 0) {
        // Scale movement for better feel
        int8_t mouseX = constrain(deltaX * x_multiplier / 10, -127, 127);
        int8_t mouseY = constrain(deltaY * y_multiplier / 10, -127, 127);

        ESP_LOGI(TAG, "Touchpad move: x=%d, y=%d (delta: %d, %d)", mouseX, mouseY, deltaX, deltaY);
        usb_hid_mouse_move(mouseX, mouseY);

        lastX = x;
        lastY = y;
    }
}

/*=========================================================================*/
/*  decodeCanBus() - Process CAN messages and trigger USB HID events      */
/*=========================================================================*/

bool isvalueinarray(int val, int *arr, int size)
{
    for (int i = 0; i < size; i++) {
        if (arr[i] == val)
            return true;
    }
    return false;
}

void decodeCanBus(unsigned long canId, uint8_t len, uint8_t *buf)
{
#ifdef DEBUG_CanResponse
    if (!isvalueinarray(canId, ignored_responses, ignored_responses_size)) {
        ESP_LOGI(TAG, "CAN ID: 0x%03lX, DLC:%d, Data:", canId, len);
        for (int i = 0; i < len; i++) {
            printf("%02X ", buf[i]);
        }
        printf("\n");
    }
#endif

    // Process different CAN messages
    switch (canId) {
        case MSG_IN_INPUT: {  // 0x267 - Buttons and joystick
            if (len >= 3) {
                uint8_t type  = buf[0];
                uint8_t value = buf[1];
                uint8_t state = buf[2];

                if (type == MSG_INPUT_BUTTON) {
                    handleButton(value, state);
                } else if (type == MSG_INPUT_STICK || type == MSG_INPUT_CENTER) {
                    handleJoystick(value, state);
                }
            }
            break;
        }

        case MSG_IN_ROTARY: {  // 0x264 - Rotary encoder
            if (len >= 2 && RotaryInitPositionSet) {
                unsigned int newPosition = (buf[0] << 8) | buf[1];
                int          delta       = (int) newPosition - (int) rotaryposition;

                // Handle wraparound
                if (delta > 32768)
                    delta -= 65536;
                else if (delta < -32768)
                    delta += 65536;

                if (delta != 0) {
                    handleRotary(delta);
                    rotaryposition = newPosition;
                }
            } else if (!RotaryInitPositionSet && len >= 2) {
                // Set initial position
                rotaryposition        = (buf[0] << 8) | buf[1];
                RotaryInitPositionSet = true;
                ESP_LOGI(TAG, "Rotary initial position: %u", rotaryposition);
            }
            break;
        }

        case MSG_IN_TOUCH: {  // 0xBF - Touchpad
            if (len >= 8) {
                // Touchpad data format varies by version
                if (TouchpadInitIgnoreCounter < TouchpadInitIgnoreCount) {
                    TouchpadInitIgnoreCounter++;
                    TouchpadInitDone = true;
                    ESP_LOGI(TAG, "Touchpad init progress: %d/%d", TouchpadInitIgnoreCounter,
                             TouchpadInitIgnoreCount);
                    break;
                }

#ifdef MOUSE_V1
                // V1 format: touch type at buf[1], coordinates in specific positions
                uint8_t touchType = buf[1];

                if (touchType == SINGLE_TOUCH) {
                    int16_t x = (int8_t) buf[4];  // Signed 8-bit
                    int16_t y = (int8_t) buf[5];  // Signed 8-bit
                    handleTouchpad(x, y, touchType);
                } else if (touchType == FINGER_REMOVED) {
                    handleTouchpad(0, 0, touchType);
                }
#else
                // V2 format: 16-bit coordinates
                uint8_t touchType = buf[6];

                if (touchType != FINGER_REMOVED) {
                    int16_t x = (buf[2] << 8) | buf[3];
                    int16_t y = (buf[4] << 8) | buf[5];
                    handleTouchpad(x, y, touchType);
                } else {
                    handleTouchpad(0, 0, touchType);
                }
#endif
            }
            break;
        }

        case MSG_IN_ROTARY_INIT: {  // 0x277
            ESP_LOGI(TAG, "Rotary Init Success");
            RotaryInitSuccess = true;
            break;
        }

        case MSG_IN_STATUS: {  // 0x5E7
            if (buf[4] == MSG_STATUS_NO_INIT) {
                ESP_LOGW(TAG, "iDrive lost init - reinitializing");
                RotaryInitSuccess         = false;
                LightInitDone             = false;
                TouchpadInitDone          = false;
                previousMillis            = 0;
                CoolDownMillis            = 0;
                TouchpadInitIgnoreCounter = 0;
                controllerReady           = false;

                // Reinitialize
                iDriveInit();
                iDriveTouchpadInit();
            }
            break;
        }
    }
}

--- src\main.cpp ---
#include <cstdio>

#include "driver/twai.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "idrive.h"
#include "settings.h"
#include "usb_hid_device.h"
#include "variables.h"

#define RX_PIN 4
#define TX_PIN 5

static const char *TAG = "MAIN";

// Helper to get current time in milliseconds (similar to Arduino millis())
static uint32_t getMillis()
{
    return (uint32_t) (esp_timer_get_time() / 1000ULL);
}

static void setupTWAI()
{
    // For 500 kbps
    twai_general_config_t g_config = {};
    g_config.mode                  = TWAI_MODE_NORMAL;
    g_config.tx_io                 = (gpio_num_t) TX_PIN;
    g_config.rx_io                 = (gpio_num_t) RX_PIN;
    g_config.clkout_io             = GPIO_NUM_NC;
    g_config.bus_off_io            = GPIO_NUM_NC;
    g_config.tx_queue_len          = 5;
    g_config.rx_queue_len          = 5;
    g_config.alerts_enabled        = TWAI_ALERT_NONE;
    g_config.clkout_divider        = 0;
    g_config.intr_flags            = ESP_INTR_FLAG_LEVEL1;

    twai_timing_config_t t_config = TWAI_TIMING_CONFIG_500KBITS();

    twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

    esp_err_t err = twai_driver_install(&g_config, &t_config, &f_config);
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "TWAI driver installed");
    } else {
        ESP_LOGE(TAG, "TWAI driver installation failed: %s", esp_err_to_name(err));
        return;
    }

    err = twai_start();
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "TWAI driver started");
    } else {
        ESP_LOGE(TAG, "TWAI driver start failed: %s", esp_err_to_name(err));
    }
}

extern "C" void app_main(void)
{
    ESP_LOGI(TAG, "ESP-IDF iDrive Project - Starting up...");

    // Initialize global variables
    previousMillis = getMillis();

    // Initialize USB HID device
    usb_hid_device_init();
    ESP_LOGI(TAG, "USB HID device initialized");

    // Small delay to let USB enumerate
    vTaskDelay(pdMS_TO_TICKS(1000));

    setupTWAI();

    iDriveInit();
    iDriveTouchpadInit();

    // Enter main loop
    while (true) {
        // If we haven't done so, check if controller can be marked ready
        if (!controllerReady && RotaryInitSuccess && TouchpadInitDone) {
            if (CoolDownMillis == 0)
                CoolDownMillis = getMillis();
            if (getMillis() - CoolDownMillis > controllerCoolDown) {
                controllerReady = true;
                ESP_LOGI(TAG, "iDrive controller ready!");
            }
        }

        // Receive any incoming CAN frames (non-blocking)
        twai_message_t message;
        esp_err_t      ret = twai_receive(&message, 0);  // timeout=0 => non-blocking
        if (ret == ESP_OK) {
            // decode - this is where button presses and touchpad events are handled
            decodeCanBus(message.identifier, message.data_length_code, message.data);
        }

        // Periodic tasks
        uint32_t now = getMillis();

        // Light init logic
        if (!LightInitDone) {
            if (previousMillis == 0)
                previousMillis = now;
            if (now - previousMillis > iDriveInitLightTime) {
                LightInitDone = true;
            } else {
                do_iDriveLight();
            }
        }

        // iDrive Poll
        iDrivePoll(iDrivePollTime);

        // iDrive Light keepalive
        iDriveLight(iDriveLightTime);

        // Tiny delay so we don't hog the CPU
        vTaskDelay(pdMS_TO_TICKS(5));
    }
}

--- src\usb_hid_device.c ---
#include "usb_hid_device.h"

#include <string.h>

#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "freertos/task.h"

// ESP TinyUSB includes
#include "class/hid/hid_device.h"
#include "tinyusb.h"

static const char *TAG = "USB_HID";

// Mutex for thread safety
static SemaphoreHandle_t hid_mutex = NULL;

// Connection state
static bool usb_connected = false;

// Report IDs
enum { REPORT_ID_KEYBOARD = 1, REPORT_ID_MOUSE, REPORT_ID_CONSUMER };

// HID Report Descriptor
static const uint8_t hid_report_descriptor[] = {
    TUD_HID_REPORT_DESC_KEYBOARD(HID_REPORT_ID(REPORT_ID_KEYBOARD)),
    TUD_HID_REPORT_DESC_MOUSE(HID_REPORT_ID(REPORT_ID_MOUSE)),
    TUD_HID_REPORT_DESC_CONSUMER(HID_REPORT_ID(REPORT_ID_CONSUMER))};

// Current reports
static hid_keyboard_report_t keyboard_report = {0};
static hid_mouse_report_t    mouse_report    = {0};

// Configuration descriptor
static const uint8_t hid_configuration_descriptor[] = {
    // Configuration number, interface count, string index, total length, attribute, power in mA
    TUD_CONFIG_DESCRIPTOR(1, 1, 0, TUD_CONFIG_DESC_LEN + TUD_HID_DESC_LEN, 0, 100),

    // Interface number, string index, protocol, report descriptor len, EP In address, size &
    // polling interval
    TUD_HID_DESCRIPTOR(0, 0, false, sizeof(hid_report_descriptor), 0x81, 16, 10),
};

// Invoked when device is mounted
void tud_mount_cb(void)
{
    ESP_LOGI(TAG, "USB mounted");
    usb_connected = true;
}

// Invoked when device is unmounted
void tud_umount_cb(void)
{
    ESP_LOGI(TAG, "USB unmounted");
    usb_connected = false;
}

// Invoked when usb bus is suspended
void tud_suspend_cb(bool remote_wakeup_en)
{
    (void) remote_wakeup_en;
    ESP_LOGI(TAG, "USB suspended");
}

// Invoked when usb bus is resumed
void tud_resume_cb(void)
{
    ESP_LOGI(TAG, "USB resumed");
}

// Invoked to get HID report descriptor
uint8_t const *tud_hid_descriptor_report_cb(uint8_t itf)
{
    (void) itf;
    return hid_report_descriptor;
}

// Invoked when received GET_REPORT control request
uint16_t tud_hid_get_report_cb(uint8_t itf, uint8_t report_id, hid_report_type_t report_type,
                               uint8_t *buffer, uint16_t reqlen)
{
    (void) itf;
    (void) report_type;
    (void) reqlen;

    switch (report_id) {
        case REPORT_ID_KEYBOARD:
            memcpy(buffer, &keyboard_report, sizeof(keyboard_report));
            return sizeof(keyboard_report);

        case REPORT_ID_MOUSE:
            memcpy(buffer, &mouse_report, sizeof(mouse_report));
            return sizeof(mouse_report);

        default:
            return 0;
    }
}

// Invoked when received SET_REPORT control request
void tud_hid_set_report_cb(uint8_t itf, uint8_t report_id, hid_report_type_t report_type,
                           uint8_t const *buffer, uint16_t bufsize)
{
    (void) itf;
    (void) report_id;
    (void) report_type;
    (void) buffer;
    (void) bufsize;
}

// USB task
static void usb_device_task(void *arg)
{
    (void) arg;

    while (1) {
        tud_task();
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

// Initialize USB HID
void usb_hid_device_init(void)
{
    ESP_LOGI(TAG, "Initializing USB HID device");

    // Create mutex
    hid_mutex = xSemaphoreCreateMutex();

    // Configure USB descriptors
    static tusb_desc_device_t descriptor = {.bLength            = sizeof(descriptor),
                                            .bDescriptorType    = TUSB_DESC_DEVICE,
                                            .bcdUSB             = 0x0200,
                                            .bDeviceClass       = 0,
                                            .bDeviceSubClass    = 0,
                                            .bDeviceProtocol    = 0,
                                            .bMaxPacketSize0    = CFG_TUD_ENDPOINT0_SIZE,
                                            .idVendor           = 0x303A,  // Espressif VID
                                            .idProduct          = 0x4002,
                                            .bcdDevice          = 0x0100,
                                            .iManufacturer      = 0x01,
                                            .iProduct           = 0x02,
                                            .iSerialNumber      = 0x03,
                                            .bNumConfigurations = 0x01};

    // Определите языковой дескриптор отдельно
    static const char language_descriptor[] = {0x09, 0x04};

    // Теперь используйте его в массиве
    static const char *string_descriptor[] = {
        language_descriptor,  // Language
        "BMW",                // Manufacturer
        "iDrive Controller",  // Product
        "123456",             // Serial
        "HID Interface",      // Interface
    };

    tinyusb_config_t tusb_cfg = {
        .device_descriptor        = &descriptor,
        .string_descriptor        = string_descriptor,
        .string_descriptor_count  = sizeof(string_descriptor) / sizeof(string_descriptor[0]),
        .external_phy             = false,
        .configuration_descriptor = hid_configuration_descriptor,
    };

    ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));

    // Create USB task
    xTaskCreate(usb_device_task, "TinyUSB", 4096, NULL, 5, NULL);

    ESP_LOGI(TAG, "USB HID initialized");
}

// Keyboard functions
void usb_hid_keyboard_press(uint8_t keycode)
{
    if (!usb_connected)
        return;

    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        // Find empty slot
        for (int i = 0; i < 6; i++) {
            if (keyboard_report.keycode[i] == 0) {
                keyboard_report.keycode[i] = keycode;
                break;
            }
        }

        tud_hid_n_report(0, REPORT_ID_KEYBOARD, &keyboard_report, sizeof(keyboard_report));
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_keyboard_release(uint8_t keycode)
{
    if (!usb_connected)
        return;

    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        // Remove keycode
        for (int i = 0; i < 6; i++) {
            if (keyboard_report.keycode[i] == keycode) {
                keyboard_report.keycode[i] = 0;
                break;
            }
        }

        tud_hid_n_report(0, REPORT_ID_KEYBOARD, &keyboard_report, sizeof(keyboard_report));
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_keyboard_press_and_release(uint8_t keycode)
{
    usb_hid_keyboard_press(keycode);
    vTaskDelay(pdMS_TO_TICKS(50));
    usb_hid_keyboard_release(keycode);
}

// Media key functions
void usb_hid_media_key_press(uint8_t keycode)
{
    if (!usb_connected)
        return;

    uint16_t usage = keycode;
    tud_hid_n_report(0, REPORT_ID_CONSUMER, &usage, 2);
}

void usb_hid_media_key_release(uint8_t keycode)
{
    if (!usb_connected)
        return;

    uint16_t usage = 0;
    tud_hid_n_report(0, REPORT_ID_CONSUMER, &usage, 2);
}

void usb_hid_media_key_press_and_release(uint8_t keycode)
{
    usb_hid_media_key_press(keycode);
    vTaskDelay(pdMS_TO_TICKS(50));
    usb_hid_media_key_release(keycode);
}

// Mouse functions
void usb_hid_mouse_move(int8_t x, int8_t y)
{
    if (!usb_connected)
        return;

    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.x = x;
        mouse_report.y = y;
        tud_hid_n_report(0, REPORT_ID_MOUSE, &mouse_report, sizeof(mouse_report));
        mouse_report.x = 0;
        mouse_report.y = 0;
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_mouse_button_press(uint8_t button)
{
    if (!usb_connected)
        return;

    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.buttons |= button;
        tud_hid_n_report(0, REPORT_ID_MOUSE, &mouse_report, sizeof(mouse_report));
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_mouse_button_release(uint8_t button)
{
    if (!usb_connected)
        return;

    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.buttons &= ~button;
        tud_hid_n_report(0, REPORT_ID_MOUSE, &mouse_report, sizeof(mouse_report));
        xSemaphoreGive(hid_mutex);
    }
}

void usb_hid_mouse_click(uint8_t button)
{
    usb_hid_mouse_button_press(button);
    vTaskDelay(pdMS_TO_TICKS(50));
    usb_hid_mouse_button_release(button);
}

void usb_hid_mouse_scroll(int8_t wheel)
{
    if (!usb_connected)
        return;

    if (xSemaphoreTake(hid_mutex, portMAX_DELAY) == pdTRUE) {
        mouse_report.wheel = wheel;
        tud_hid_n_report(0, REPORT_ID_MOUSE, &mouse_report, sizeof(mouse_report));
        mouse_report.wheel = 0;
        xSemaphoreGive(hid_mutex);
    }
}

bool usb_hid_is_connected(void)
{
    return usb_connected && tud_ready();
}

--- src\variables.cpp ---
#include "variables.h"
#include <cstddef>

// default states
unsigned long previousMillis = 0;
unsigned long CoolDownMillis = 0;
int init_can_count = 0;
const int max_can_init_attempts = 15;
bool RotaryInitSuccess = false;
bool PollInit = false;
bool TouchpadInitDone = false;
bool LightInitDone = false;
bool RotaryInitPositionSet = false;
bool controllerReady = false;
bool touching = false;
bool rotaryDisabled = false;

bool iDriveLightOn = true;

unsigned int rotaryposition = 0;

int PreviousX = 0;
int PreviousY = 0;
int ResultX = 0;
int ResultY = 0;
int TouchpadInitIgnoreCounter = 0;

const int8_t mouse_low_range = -128;
const int8_t mouse_high_range = 127;
const int8_t mouse_center_range = 0;
const float powerValue = 1.4;

const int mouse_low_range_v2 = 0;
const int mouse_high_range_v2 = 510;
const int mouse_center_range_v2 = mouse_high_range_v2 / 2;
const int x_multiplier = 2;
const int y_multiplier = 12;

// Key states
uint8_t stati[256] = {0};


